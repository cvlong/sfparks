{% extends 'base.html' %} 

{% block title %}SFparks{% endblock %}

{% block head %} 
{% endblock %}

{% block body %}

    <div id="origin-input">
        <form action="/query" method="GET">
            <label for="field-origin">Starting location:</label>
            <input type="text" name="origin" id="field-origin">

            <label for="dropdown-maxtime">Time there:</label>
                <select name="time">
                  <option value="5">5 mins.</option>
                  <option value="10">10 mins.</option>
                  <option value="15">15 mins.</option>
                  <option value="20">20 mins.</option>
                  <option value="30">30 mins.</option>
                  <option value="45">45 mins.</option>
                </select>

            <label for="field-routing">Routing profile:</label>
                <input type="radio" name="routing" value="walking">Walking
                <input type="radio" name="routing" value="cycling">Cycling

        <input type="submit" value="Let's go!">
        </form>
    </div>

<!-- separate button to get user's current location -->
    <div>
        <button id="use-current-location">Use current location</button>
        <span id="output"></span>
    </div>


    <div id='map' class='home-map'></div>
    <nav id='menu' class='toggle-menu'></nav>

<!-- Could move scripts to a separate JS file, then link to it here: src="/static, ETC" -->

<script>

var map = new mapboxgl.Map({
    container: 'map',
    style: 'mapbox://styles/mapbox/streets-v9',
    // toggle with? mapbox://styles/mapbox/satellite-streets-v9
    center: [-122.431, 37.773], // center of SF
    zoom: 12.5
});

// Disable map rotation using right click + drag
map.dragRotate.disable();

// Disable map rotation using touch rotation gesture
map.touchZoomRotate.disableRotation();


var park_markers = {{ parks | safe }}; // '| safe' to disable HTML autoescape


// Add POPOS + POSM data as source rather than layer ===========================
// var popos_markers = park_markers.features.filter(function(source) {
//     return source.features.properties.type === 'popos';
// });

// console.log(popos_markers)

// var posm_markers = park_markers.features.filter(function(source) {
//     return source.features.properties.type === 'posm';
// });

// map.getSource('popos_markers').setData(popos_markers);
// ============================================================================>



map.on('load', function () {
    
    // Add park marker data as a new GeoJSON source.
    map.addSource("park_markers", {
        "type": "geojson",
        "data":  park_markers
    });

// Adding POPOS and POSM data as layers of the park_markers source==============

    // Add a layer showing the POPOS markers.
    map.addLayer({
        "id": "popos_markers", // unique layer name
        "type": "circle", // how the layer is rendered (symbol or circle)
        "source": "park_markers", // source data
        "filter": ["==", 'type', 'popos'], // specifies conditions on source features
        "layout": { // defines how layer data is passed to the GPU; can link to
            // this layout in another layer with the 'ref' layer property to decrease
            // processing time and memory
            'visibility': 'visible' 
        },
        'paint': {
            'circle-radius': 10, // units in pixels
            'circle-color': "#ff0000",
            'circle-opacity': {
                "stops": [[3, 0.2], [15,0.8]] // for interpolated values b/w 0.2 - 0.8
            }
        },
        'paint.popos': {
            // 'xxxx' // class-specific paint properties
        }
    });

    // Add a layer showing the POSM markers.
    map.addLayer({
        "id": "posm_markers",
        "type": "circle",
        "source": "park_markers",
        "filter": ["==", 'type', 'posm'],
        "layout": {
            'visibility': 'visible' 
        },
        'paint': { 
            'circle-radius': 10, // units in pixels
            'circle-color': '#1aa3ff',
            'circle-opacity': {
                "stops": [[3, 0.2], [15,0.8]] // for interpolated values b/w 0.2 - 0.8
            }
        },
        'paint.posm': {
            // 'xxxx' // class-specific paint properties
        }
    });

    // Add a layer showing a user's favorites.
    map.addLayer({
        "id": "fav-markers",
        "type": "circle",
        "source": "park_markers",
        "filter": ["==", 'favorite', 'True'],
        "layout": {
            'visibility': 'visible' 
        },
        'paint': { 
            'circle-radius': 15, // units in pixels
            'circle-color': '#ff00bf',
            'circle-opacity': 1.0
        },
        'paint.favorites': {
            // 'xxxx' // class-specific paint properties
        }
    });
})
//=============================================================================>


// // Only keep this section if it's possible to add POPOS + POSM data with 
// // .addSource() rather than with .addLayer() ================================

//     // Add POPOS marker data as a new GeoJSON source.
//     map.addSource("popos_markers", {
//         "type": "geojson",
//         "data":  popos_markers,
//         "cluster": true,
//         "clusterMaxZoom": 14, // Max zoom to cluster points on
//         "clusterRadius": 23 // Radius of each cluster when clustering points
//     });

//     popos_markers.features.forEach(function(feature) {
//         feature.properties["marker-symbol"] = "garden"
//     });

//     // Add a layer showing the POPOS markers.
//     map.addLayer({
//         "id": "popos_markers",
//         "type": "symbol",
//         "source": "popos_markers",
//         "layout": {
//             "icon-image": "{marker-symbol}-15",
//             'visibility': 'visible' // not sure if this is necessary
//         }
//     });

//     // Display the POPOS data in three layers, each filtered to a range of
//     // count values with a different fill color.
//     var layers = [
//         [20, '#f28cb1'],
//         [10, '#f1f075'],
//         [0, '#51bbd6']
//     ];

//     layers.forEach(function (layer, i) {
//         map.addLayer({
//             "id": "cluster-" + i,
//             "type": "circle",
//             "source": "popos_markers",
//             "paint": {
//                 "circle-color": layer[1],
//                 "circle-radius": 14
//             },
//             "filter": i == 0 ?
//                 [">=", "point_count", layer[0]] :
//                 ["all",
//                     [">=", "point_count", layer[0]],
//                     ["<", "point_count", layers[i - 1][0]]]
//         });
//     });

//     // Add a layer for the POPOS clusters' count labels.
//     map.addLayer({
//         "id": "cluster-count",
//         "type": "symbol",
//         "source": "popos_markers",
//         "layout": {
//             "text-field": "{point_count}",
//             "text-font": [
//                     "DIN Offc Pro Medium",
//                     "Arial Unicode MS Bold"
//                 ],
//             "text-size": 12
//         }
//     });


//     // Add POSM marker data as a new GeoJSON source.
//     map.addSource("posm_markers", {
//         "type": "geojson",
//         "data":  posm_markers
//     });

//     posm_markers.features.forEach(function(feature) {
//         feature.properties["marker-symbol"] = "monument"
//     });

//     // Add a layer showing the POSM markers.
//     map.addLayer({
//         "id": "posm_markers",
//         "type": "symbol",
//         "source": "posm_markers",
//         "layout": {
//             "icon-image": "{marker-symbol}-15",
//             'visibility': 'visible' // not sure if this is necessary
//         }
//     });
// });
// ============================================================================>

// Fit map to posm_markers boundary, since they are the most spread out
var bounds = new mapboxgl.LngLatBounds();

park_markers.features.forEach(function(feature) {
    bounds.extend(feature.geometry.coordinates);
});

map.fitBounds(bounds, {padding: '50'});
// end fit to bounds


// Add functionality for toggling layers via menu selection
addLayer('POPOS', 'popos_markers');
addLayer('SF parks', 'posm_markers');

function addLayer(name, id) {
    var link = document.createElement('a');
    link.href = '#';
    link.className = 'active';
    link.textContent = name;

    link.onclick = function (e) {
        e.preventDefault();
        e.stopPropagation();

        var visibility = map.getLayoutProperty(id, 'visibility');

        if (visibility === 'visible') {
            map.setLayoutProperty(id, 'visibility', 'none');
            this.className = '';
        } else {
            this.className = 'active';
            map.setLayoutProperty(id, 'visibility', 'visible');
        }
    };

    var layers = document.getElementById('menu');
    layers.appendChild(link);
}
// End toggle layers.


// Create a popup info box on hover, but don't add it to the map yet.
var popup = new mapboxgl.Popup({
    closeButton: false,
    closeOnClick: false
});


// Change the cursor style as a UI indicator.
map.on('mousemove', function(e) {
    // Find all rendered features from the given layers.
    var features = map.queryRenderedFeatures(e.point, { layers: ['popos_markers', 'posm_markers'] });
    
    // Indicate that the symbols are clickable by changing the cursor style to 'pointer'.
    map.getCanvas().style.cursor = (features.length) ? 'pointer' : '';

    if (!features.length) {
        popup.remove();
        return;
    }

    var feature = features[0];
    // Populate the popup and set its coordinates based on the feature found.
    
    var htmlString = "<div><p>" + feature.properties.name + "</p><button id=" + feature.properties.id + " class='favorite-btn";
    if(feature.properties.favorite){
        htmlString += "favorite";
    }

    htmlString += "' onclick='updateFavorite(" + feature.properties.id + ")'>&hearts; Favorite</button></div>";

    popup.setLngLat(feature.geometry.coordinates)
        .setHTML(htmlString)
        .addTo(map);
});
// End popup boxes.


//not getting new info from db, just changing color
//resassign html when you click fav say its fave. instead of lookinbg in the db set it as fave

// force the css to look like it has a feature
// click favorites capture the html of that window class.html(returns html for window with faves color) -- then reassign that window to the markert
// then next time it already knows its a fave

// on load things should show up as css favorited


function updateFavorite(feature, id) {
    console.log(feature);
    console.log(id);
    $('.favorite-btn#' + id).toggleClass('favorite', function (){
        $.post('/toggle-favorites.json', {'id': id}, toggleFavoritesSuccess);

        // Also toggle geojson element to False
        //     feature.properties.favorite = False;
        
    });
}


function toggleFavoritesSuccess(result) {
    console.log(result.status);
    var id = result.id;
    console.log(id);
}


//LAUREN:
//there's no way for the button to remember it's a favorite
//so modify geojson by directly accessing geojson popos.properties....favorite - then toggle to true
//when creating the popup, add in-line css, or add a class whether feature.properties.favorite is true
//could also set a diff marker color or marker icon if it's a favorite
//so can change style based on this underlying 
//then another layer filtering all not favoritedthen another layer with the favorites


//then update favorite/not_favorite on geojson object


//property in geojson obj about whether it's favorited or not, then use that property to determine the button class in the popup
// [this is for things favorited before loading the page]

//can we add a property to a geojson object within a map after the map has been displayed
//if so, then use the button class property

//if not, then maintain a list of buttons that are favorites
//start that from the server - assigning to a js variable
//then manage the list in addToFavorites
//then access the list in the btn class - function that returns the class based on whether or not it's in the list








//creating a new box every time, not checking whether that thing has been favorited
//every time it's pulled up - is this item favorited? check. then if not, show not red button

//OR when someone favorites it, make an ajax call to add to the session - some way to itentify in the session what has been favorited
//List of favorited park ids, or 



// Collect user's current location via browser
$('#use-current-location').on('click', findCurrentLocation);

var currentLatitude;
var currentLongitude;

var output = document.getElementById("output");


function findCurrentLocation(evt) {

    if (!navigator.geolocation) {
        output.innerHTML = "<p>Geolocation is not supported by your browser</p>";
        return;
    }

    function success(position) {
        currentLatitude  = position.coords.latitude;
        currentLongitude = position.coords.longitude;
        console.log('latitude: ' + currentLatitude + ' \n longitude: ' + currentLongitude);
        $.post('/current-location.json', {'latitude': currentLatitude, 'longitude': currentLongitude}, sendLatLngSuccess);
        output.innerHTML = '<p>Latitude is ' + currentLatitude + '<br>Longitude is ' + currentLongitude + '</p>';
    };

    function error() {
        output.innerHTML = "Unable to retrieve your location";
    };

    output.innerHTML = "<p>Locating…</p>";

    navigator.geolocation.getCurrentPosition(success, error);
}


function sendLatLngSuccess(result) {
    console.log(result.status);
    console.log(result.latitude);
    // $('#field-origin').html(newLatLng);
}



// ON clickprevents form submission, finds current location, then go to route w/o using Ajax

// prevent default,
// get curret location
// then submit

// In JS to redirect to other page, AKA python route

// // Send currentLatitude, currentLongitude back to server??
//     $.post('/current-location.json', { //ajax goes to this route, and sends this json like form data
//         'latitude': currentLatitude,
//         'longitude': currentLongitude
//         },
//         function (data) {
//             //THIS IS WHAT YOU DO WITH THE DATA - change the DOM, request something, save it
//         } //uin python, at end of route, this is what gets returned 

</script>

{% endblock %}